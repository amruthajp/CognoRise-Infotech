# -*- coding: utf-8 -*-
"""breast_Cancer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oqf7FPwvWGIT_sSqU9DQR3OdiGWonbsf

**IMPORTING LIBRARIES**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix,accuracy_score,ConfusionMatrixDisplay

"""**LOADING** **DATASET**"""

df=pd.read_csv('/content/breast cancer.csv')
df

"""**DATA PREPROCESSING**"""

# Printing first five rows
df.head()

# Printing the last 5 rows
df.tail()

# Printing column names
df.columns

# Printing the datatype
df.dtypes

# Checking for missing values
df.isna().sum()

# Number of rows and columns
df.shape

# Describing dataset
df.describe()

# Number of unique elements in each column
df.nunique()

#get a concise summary of the DataFrame
df.info()

#Dropping unwanted columns
df.drop(['id','Unnamed: 32'],axis=1,inplace=True)

#Converting datatype to numerical
data=LabelEncoder()
df['diagnosis']=data.fit_transform(df['diagnosis'])

df['diagnosis'].value_counts()

"""This is a balanced dataset

**DATA VISUALIZATION**
"""

result = df['diagnosis'].value_counts()
mylabel = ['Benign', 'Malignant']
colors = ['indianred', 'steelblue']
plt.pie(x=result, labels=mylabel, autopct='%1.1f%%', colors=colors)
plt.title('Diagnosis Breakdown: Benign vs. Malignant')
plt.legend(loc='upper right', labels=mylabel,bbox_to_anchor=(1.3, 1))
plt.show()

custom_palette=['red','darkgreen']
sns.countplot(x=df['diagnosis'],data=df,palette=custom_palette)

plt.figure(figsize=(18,8))
sns.heatmap(df.corr(),annot=True,cmap='viridis')
plt.show()

"""**SEPERATING X AND Y**"""

x=df.drop(['diagnosis'],axis=1).values
x

y=df['diagnosis'].values
y

"""**SPLITTING DATA FOR TRAINING AND TESTING**"""

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=42)
x_train

x_test

y_train

y_test

"""**NORMALISATION**"""

scaler=MinMaxScaler()
x_train=scaler.fit_transform(x_train)
x_test=scaler.transform(x_test)
x_train

x_test

"""**MODEL CREATION**"""



knn=KNeighborsClassifier(n_neighbors=7)
base=GaussianNB()
svm_model=SVC()
tree=DecisionTreeClassifier(criterion='entropy')
forest=RandomForestClassifier(n_estimators=100,criterion='entropy')
models=[knn,base,svm_model,tree,forest]

"""**PERFORMANCE EVALUATION**"""

for model in models:
    print('Model is .....', model)
    model.fit(x_train, y_train)
    print("Prediction is.......")
    y_pred = model.predict(x_test)
    print(y_pred)
    print("Confusion matrix is..........")
    print("Matrix is", confusion_matrix(y_test, y_pred))
    print("Accuracy score is .......")
    print("Score is", accuracy_score(y_test, y_pred))

from sklearn.metrics import classification_report
report=classification_report(y_test,y_pred)
print(report)

"""**CONFUSION MATRIX**"""

cmd=confusion_matrix(y_test,y_pred)
cmd

from sklearn.metrics import ConfusionMatrixDisplay
lab=[0,1]
cmd1=ConfusionMatrixDisplay(cmd,display_labels=lab)
cmd1.plot()